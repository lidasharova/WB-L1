/* Задача 3
Реализовать аналог библиотеки Math (можно назвать MathX) с базовым набором функций, используя замыкания:
вычисление N-го числа в ряду Фибоначчи
вычисление всех чисел в ряду Фибоначчи до числа N
вычисление N-го простого числа
вычисление всех простых чисел до числа N
	Будет плюсом, если задумаетесь и об оптимизации.
 */

/* РЕШЕНИЕ
- мы начинаем с создания замыкания (анонимной функции)для избежания конфликтов имен с другими переменными
- внутри этой анонимной функции определяются методы, которые будут доступны через объект MathX.


--------> isPrime(number)- это функция, которая проверяет, является ли число простым <-------------
Если число меньше или равно 1, то оно не является простым числом, и функция возвращает false.
Если число меньше или равно 3, то оно является простым числом (простые числа 2 и 3), и функция возвращает true.
Проверка на делимость на 2 и 3:
Если число делится без остатка на 2 или 3, то оно не является простым числом, и функция возвращает false. Это оптимизация, которая позволяет исключить множество чисел, которые точно не являются простыми.
Цикл для проверки делителей: Мы начинаем проверку делителей с числа 5 и увеличиваем i на 6 на каждой итерации.
Это тоже оптимизация, так как все простые числа больше 5 могут быть записаны в виде 6k ± 1, где k - целое число. Мы проверяем только числа вида 6k - 1 и 6k + 1.
Мы проверяем, делится ли число number на i или i + 2 без остатка. Если оно делится на любое из этих чисел, то оно не является простым числом, и функция возвращает false.
Если ни одно из вышеуказанных условий не выполняется, то функция возвращает true, указывая, что число number является простым числом.
Этот алгоритм эффективно определяет простые числа и использует оптимизации для исключения большого числа делителей, что делает его быстрым для больших чисел.



--------> метод fibonacci(n) для вычисления N-го числа в ряду Фибоначчи <-------------
- Проверка на отрицательное или нулевое значение n:
Если значение n меньше или равно нулю, то метод возвращает 0. Это базовый случай для ряда Фибоначчи, где F(0) = 0.
- Проверка на значение n равное 1:
Если значение n равно 1, то метод возвращает 1. Это также базовый случай, где F(1) = 1.
- Создаются две переменные a и b, которые будут использоваться для вычисления последовательных чисел в ряду Фибоначчи.
- Цикл для вычисления числа. Мы начинаем цикл с i равным 2, так как мы уже знаем значения для n равных 0 и 1.
Цель цикла - вычислить N-е число в ряду Фибоначчи.
Временная переменная temp используется для хранения суммы двух предыдущих чисел a и b.
Значения переменных обновляются так, чтобы a стало равным предыдущему b, а b стало равным временной переменной temp.
Таким образом, на каждой итерации цикла мы переходим к следующему числу в ряду Фибоначчи, вычисляя его как сумму двух предыдущих чисел.
Возвращаем результат - значение переменной b, которое содержит это число.


-------->  метод fibonacciSequence(n), который используется для вычисления всех чисел в ряду Фибоначчи до числа N:<-----------
- Создается пустой массив sequence, в который будут добавлены числа Фибоначчи.
- Цикл для вычисления чисел Фибоначчи.
Мы начинаем цикл с i равным 0 и продолжаем до n включительно. Это позволяет нам вычислить все числа в ряду Фибоначчи до числа n.
- На каждой итерации цикла мы вызываем метод fibonacci(i) для вычисления числа Фибоначчи с индексом i и добавляем его в массив sequence
- Возвращаем массив, который содержит все числа Фибоначчи до числа n.



--------> метод nthPrime(n), который используется для вычисления N-го простого числа <-------------
Этот метод использует цикл и вспомогательную функцию isPrime для нахождения N-го простого числа и возвращает его.

- Проверка на отрицательное или нулевое значение n , так как простые числа начинаются с 2, и нулевого или отрицательного простого числа не существует.
- Создаются переменные count и number. count используется для отслеживания количества найденных простых чисел, и начальное значение number установлено на 2, так как 2 - это первое простое число.
- Мы используем цикл while, который будет выполняться до тех пор, пока не будет найдено N простых чисел.
- На каждой итерации цикла мы вызываем вспомогательную функцию isPrime(number), чтобы проверить, является ли текущее число number простым.
- Если число number является простым, то увеличиваем счетчик count на 1, чтобы отметить, что мы нашли еще одно простое число.
- В любом случае увеличиваем текущее число number на 1, чтобы перейти к следующему числу для проверки.
- Возвращаеm number - 1, так как на последней итерации мы увеличили number, но не нашли простое число, поэтому возвращаем предыдущее значение number - 1, которое будет N-м простым числом.



--------> метод primeNumbersUpTo(n)-  для вычисления всех простых чисел, которые меньше или равны числу N
Этот метод использует цикл и вспомогательную функцию isPrime для нахождения всех простых чисел, которые меньше или равны числу n, и возвращает их в виде массива.

- Создаем пустой массив primes, в который будут добавлены все простые числа до числа n.
- Мы начинаем цикл с i равным 2, так как 2 - это первое простое число, и продолжаем до числа n, которое указано в аргументе метода.
- На каждой итерации цикла вызываем вспомогательную функцию isPrime(i), чтобы проверить, является ли текущее число i простым.
- Если число i является простым, то мы добавляем его в массив primes с помощью primes.push(i).
- Возвращаем массив primes, который содержит все простые числа до числа n.

 */

const MathX = (function () {
  // Функция для проверки, является ли число простым
  function isPrime(number) {
    if (number <= 1) return false;
    if (number <= 3) return true;
    if (number % 2 === 0 || number % 3 === 0) return false;
    for (let i = 5; i * i <= number; i += 6) {
      if (number % i === 0 || number % (i + 2) === 0) return false;
    }
    return true;
  }

  return {
    // Метод для вычисления N-го числа в ряду Фибоначчи
    fibonacci: function (n) {
      if (n <= 0) return 0;
      if (n === 1) return 1;

      let a = 0;
      let b = 1;
      let temp;
      for (let i = 2; i <= n; i++) {
        temp = a + b;
        a = b;
        b = temp;
      }
      return b;
    },

    // Метод для вычисления всех чисел в ряду Фибоначчи до числа N
    fibonacciSequence: function (n) {
      const sequence = [];
      for (let i = 0; i <= n; i++) {
        sequence.push(this.fibonacci(i));
      }
      return sequence;
    },

    // Метод для вычисления N-го простого числа
    nthPrime: function (n) {
      if (n <= 0) return undefined;

      let count = 0;
      let number = 2;
      while (count < n) {
        if (isPrime(number)) {
          count++;
        }
        number++;
      }
      return number - 1;
    },

    // Метод для вычисления всех простых чисел до числа N
    primeNumbersUpTo: function (n) {
      const primes = [];
      for (let i = 2; i <= n; i++) {
        if (isPrime(i)) {
          primes.push(i);
        }
      }
      return primes;
    },
  };
})();

// Пример использования:
console.log(MathX.fibonacci(5)); // Вывод: 5
console.log(MathX.fibonacciSequence(7)); // Вывод: [0, 1, 1, 2, 3, 5, 8, 13]
console.log(MathX.nthPrime(4)); // Вывод: 7
console.log(MathX.primeNumbersUpTo(10)); // Вывод: [2, 3, 5, 7]
